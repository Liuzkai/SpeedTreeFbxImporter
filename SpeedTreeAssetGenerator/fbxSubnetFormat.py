"""
API for building formatting tree subnet built from fbx Subnet
"""

import hou
from . import classNodeNetwork as cnn
from . import fbxSubnet
from PIL import Image

def AssignMaterials(subnet):
    """ Creates s@shop_materialpath attribute to existing primitive groups
    Returns formatted subnet and matnetName"""
    treeSubnet = cnn.MyNetwork(subnet)
    treeName = subnet.name()

    for treeGeo in treeSubnet.children:
        treeGeo.parm("tx").revertToDefaults()
        treeGeo.parm("ty").revertToDefaults()
        treeGeo.parm("tz").revertToDefaults()
        treeGeoNet = cnn.MyNetwork(treeGeo)

        # Prefix of new nodes
        newNodesPrefix = "myTree"

        # Clean old sops if any
        treeGeoNet.cleanNetwork("material", "pack", "output", method="type")
        treeGeoNet.cleanNetwork("assign_materials", method="name")
        #fileNode = treeGeoNet.findNodes("type", "file")[0]
        lastSop = treeGeoNet.findLastNode()

        # Add nodes and wire

        newNodes = treeGeoNet.addNodes("attribwrangle", "pack", "output", prefix=newNodesPrefix)
        treeGeoNet.wireNodes(newNodes, lastSop)

        # Add vex snippet to attribute wrangle. Create s@shop_materialpath to primitives
        assignWrangle = treeGeoNet.findNodes("type","attribwrangle")[0]
        assignWrangle.setName(newNodesPrefix+"_assign_materials")
        snippetParm = assignWrangle.parm("snippet")
        matnetName = treeName + "_matnet"
        matnetPath = "../../{MATNETNAME}/".format(MATNETNAME=matnetName)
        assignSnippet = '''// Assign different materials for each primitive group
string groups[] = detailintrinsic(0, "primitivegroups");

foreach (string group; groups) {{
    if (inprimgroup(0,group,@primnum) == 1){{
        string path = "{MATNETPATH}" + re_replace("_group","",group) + "/";
        s@shop_materialpath = opfullpath(path);
        }}

    }}
        '''.format(MATNETPATH=matnetPath)
        snippetParm.set(assignSnippet)
        assignWrangle.setParms({"class": 1})

        # Layout children
        treeGeo.layoutChildren(vertical_spacing=1)
        # Set display flag
        treeGeoNet.findLastNode().setDisplayFlag(True)
        treeGeoNet.findLastNode().setRenderFlag(True)

        print("Created MaterialAssignments for " + treeGeoNet.name)
    return subnet, matnetName


def materialDirectory(treeSubnet):
    """
    :param treeSubnet: hou node object of the tree subnet
                       (generated by fbxSubnet.importSpeedTreeFbx)
    :return: Directory path of the .fbx file
    """
    # Query tree subnets
    treeSubnetNet = cnn.MyNetwork(treeSubnet)
    treeGeo = treeSubnetNet.findNodes("geo", method="type")

    treeGeoNet = cnn.MyNetwork(treeGeo[0])
    fileNode = treeGeoNet.findNodes("file", method="type")[0]

    # Get fbx file current directory
    fileNodeFilePath = fileNode.parm("file").eval()
    lastSlashIndex = fileNodeFilePath.rfind("/")
    fileNodeDirPath = fileNodeFilePath[0: lastSlashIndex]

    return fileNodeDirPath


def texturePathTemplate(matDir, materialName, extension, texType=""):
    """
    Returns texture path of texture. Assumes that material name has _MAT
    Example: Material Builder name: BostonFernLeaflets_Mat
             Texture will be path/to/dir/BostonFernLeaflets_Normal.png
    :param matDir: directory path of the texture files
    :param materialName: name of the material
    :param extension: extension of the texture file
    :param texType: normal, opacity, etc. Empty is diffuse
    :return: The full path of the texture
    """
    materialName = materialName.replace("_Mat", "")
    texType = "_" + texType if texType else ""
    return "{MATDIR}/{MATERIALNAME}{TEXTYPE}{EXTENSION}".format(MATDIR=matDir,
                                                       MATERIALNAME=materialName,
                                                       TEXTYPE=texType,
                                                       EXTENSION=extension)


def createMatnet(treeSubnet, matnetName):
    """
    Creates matnet with materials assigned to each of the groups
    :param treeSubnet: Tree Subnet with imported Speed tree fbx geo nodes
    :param matnetName: Name of the matnet for the tree subnet
    :return: None
    """
    # Create Matnet
    treeMatnet = treeSubnet.createNode("matnet", matnetName)

    # Query first tree geo node in subnet
    treeGeo = treeSubnet.children()[0]
    treeGeoNet = cnn.MyNetwork(treeGeo)

    # Get variables
    treeName = treeSubnet.name()

    # Create Redshift material networks based on existing primitive groups
    groupNodes = treeGeoNet.findNodes("group", method="name")
    groupNameParms = [groupNode.parm("crname") for groupNode in groupNodes]
    groupMaterials = [groupNameParm.eval().replace("_group", "") for groupNameParm in groupNameParms]

    # Get path of the materials
    matDir = materialDirectory(treeSubnet)

    # Initialize Redshift Material Builders
    for materialName in groupMaterials:
        rsmb = treeMatnet.createNode("redshift_vopnet", materialName)
        rsmbOut = rsmb.children()[0]
        shader = rsmb.children()[1]
        
        # Create Diffuse
        colorVop = rsmb.createNode("redshift::TextureSampler", "Color")
        colorVop.setParms({"tex0_colorSpace": "sRGB"})
        colorPath = texturePathTemplate(matDir, materialName, ".png")
        colorVop.setParms({"tex0": colorPath})
        # Create Normal
        normalVop = rsmb.createNode("redshift::TextureSampler", "Normal")
        normalVop.setParms({"tex0_colorSpace": "Raw"})
        normalPath = texturePathTemplate(matDir, materialName, ".png", texType="Normal")
        normalVop.setParms({"tex0": normalPath})
        # Create Bump Vop
        bumpVop = rsmb.createNode("redshift::BumpMap")
        # Connect Diffuse
        shader.setInput(0, colorVop, 0)
        if "leaf" in materialName.lower() or "leaves" in materialName.lower():
            shader.setInput(3, colorVop, 0)  # Translucency
            shader.setParms({"transl_weight": 0.25})
        # Connect Bump Vop
        shader.setInput(52, bumpVop, 0)
        # Connect Normal
        bumpVop.setInput(0, normalVop, 0)

        # Find Opacity Image
        try:
            texOpacityPath = texturePathTemplate(matDir, materialName, ".png", texType="Opacity")
            # Sample Opacity Image
            img = Image.open(texOpacityPath)
            imgData = list(img.getdata(band=0))
            hasAlpha = 0 in imgData  # True if image has 0 in opacity texture
            img.close()
        except FileNotFoundError:
            hasAlpha = None
        # Create Sprite Vop if Opacity tex has 0 (default opacity is full white)
        if hasAlpha:
            # Create Sprite Vop if Opacity image has data
            spriteVop = rsmb.createNode("redshift::Sprite")
            spriteVop.setParms({"tex0_colorSpace": "Raw"})
            spritePath = texOpacityPath
            spriteVop.setParms({"tex0": spritePath})
            # Connect Sprite Vop
            rsmbOut.setInput(0, spriteVop, 0)
            spriteVop.setInput(0, shader, 0)
        # Layout texture and shader nodes
        rsmb.layoutChildren()

    # Format tree matnet
    treeMatnet.layoutChildren(vertical_spacing=1)

    print("Materials Created for " + treeSubnet.name())

